<!DOCTYPE html>
<html>

<body>

<script src="https://cdn.jsdelivr.net/npm/@biconomy/mexa@1/dist/mexa.js"></script>
<script type="text/javascript" src="./truffle-contract.min.js"></script>
<script type="text/javascript" src="web3.min.js"></script>
<script type="text/javascript" src="./SoapPunkCollectiblesChild_abi.js"></script>
<script>

const contractAddress = "0xd6C120F1eca107B4c32a04b1fEb35ca9FFA9002a";   // Please add your deployed contract address here
const biconomyAPIKey = "";  // add your api  key from the dashboard

const parentChainId = 5; // chain id of the network tx is signed on
const maticProvider = "https://rpc-mumbai.matic.today"

//const Web3 = require("web3");

//const sigUtil = require("eth-sig-util");

const ethEnabled = () => {
    if (window.ethereum) {
        window.web3 = new Web3(window.ethereum);
        window.ethereum.enable();
        return true;
    }
    return false;
}

console.log(ethEnabled);

if (window.web3) {
  web3Provider = window.web3.currentProvider;
}

web3 = new Web3(web3Provider);

const biconomy = new Biconomy(
	 new Web3.providers.HttpProvider(maticProvider),
    {
      apiKey: biconomyAPIKey,
      debug: true
    }
  );
const getWeb3 = new Web3(biconomy);

const contract = new getWeb3.eth.Contract(config.contract.abi, contractAddress);
const amount = "1000000000000000000";
const recipient = "0x05C351382dB8D770207F319D96ac1184c3717edE";

const domainType = [
    { name: "name", type: "string" },
    { name: "version", type: "string" },
    { name: "chainId", type: "uint256" },
    { name: "verifyingContract", type: "address" }
];

const metaTransactionType = [
    { name: "nonce", type: "uint256" },
    { name: "from", type: "address" },
    { name: "functionSignature", type: "bytes" }
];

let domainData = {
    name: "MetaToken",
    version: "1",
    chainId: parentChainId,
    verifyingContract: contractAddress
};

/*
//let biconomy, web3;
if (window.Biconomy) {
        let Biconomy = window.Biconomy;
        biconomy = new Biconomy(web3Provider,{ apiKey: biconomyAPIKey, debug: true});
        web3 = new Web3(biconomy);
}*/

biconomy.onEvent(biconomy.READY, async () => {
    const metaTransfer = async () => {
      let functionSignature = contract.methods
        //.transfer(recipient, amount)
        .balanceOf(recipient, 0)
        .encodeABI();
      executeMetaTransaction(functionSignature);
    };
    metaTransfer()

    /*
    let contract = await new web3.eth.Contract(config.contract.abi, "0xd6C120F1eca107B4c32a04b1fEb35ca9FFA9002a");
    let result = await contract.methods.balanceOf("0xCF10CD8B5Dc2323B1eb6de6164647756BAd4dE4d", 0).call();
    console.log( result );*/

}).onEvent(biconomy.ERROR, (error, message) => {
  // Handle error while initializing mexa
  console.log(error);
  alert(error.message);
});


const executeMetaTransaction = async functionSignature => {
    const accounts = await web3.eth.getAccounts();
    let userAddress = accounts[0];
    let nonce = await contract.methods.getNonce(userAddress).call();

    let message = {};
    message.nonce = parseInt(nonce);
    message.from = userAddress;
    message.functionSignature = functionSignature;

    const dataToSign = JSON.stringify({
      types: {
        EIP712Domain: domainType,
        MetaTransaction: metaTransactionType
      },
      domain: domainData,
      primaryType: "MetaTransaction",
      message: message
    });
    console.log(domainData);
    console.log(userAddress)
    web3.eth.currentProvider.send(
      {
        jsonrpc: "2.0",
        id: 999999999999,
        method: "eth_signTypedData_v4",
        params: [userAddress, dataToSign]
      },
      function(error, response) {
        console.info(`User signature is ${response.result}`);

        let { r, s, v } = getSignatureParameters(response.result);

				// logging output
        console.log(userAddress);
        console.log(JSON.stringify(message));
        console.log(message);
        console.log(getSignatureParameters(response.result));

        /*
        const recovered = sigUtil.recoverTypedSignature_v4({
          data: JSON.parse(dataToSign),
          sig: response.result
        });
        console.log(`Recovered ${recovered}`);
        let tx = contract.methods
          .executeMetaTransaction(userAddress, functionSignature, r, s, v)
          .send({
            from: userAddress
          });
        console.log(tx);*/


      }
    );
  };

  const getSignatureParameters = signature => {
    if (!web3.utils.isHexStrict(signature)) {
      throw new Error(
        'Given value "'.concat(signature, '" is not a valid hex string.')
      );
    }
    var r = signature.slice(0, 66);
    var s = "0x".concat(signature.slice(66, 130));
    var v = "0x".concat(signature.slice(130, 132));
    v = web3.utils.hexToNumber(v);
    if (![27, 28].includes(v)) v += 27;
    return {
      r: r,
      s: s,
      v: v
    };
  };
</script>

</body>

</html>
